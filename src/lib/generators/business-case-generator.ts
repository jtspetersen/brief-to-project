/**
 * Business Case Document Generator
 *
 * Converts a business-case artifact (Stage 2) into a formatted Word document.
 */
import {
  createDocument,
  Packer,
  title,
  subtitle,
  heading1,
  heading2,
  bodyText,
  labeledField,
  bulletItem,
  simpleTable,
  spacer,
  divider,
} from "./base-generator";

interface BusinessCaseData {
  projectName: string;
  executiveSummary: string;
  problemStatement: string;
  proposedSolution: string;
  benefits: { benefit: string; type: string; estimatedValue: string }[];
  costs: { category: string; amount: string; notes: string }[];
  roi: string;
  risks: string[];
  recommendation: string;
}

export async function generateBusinessCase(data: BusinessCaseData): Promise<Buffer> {
  const doc = createDocument([
    title("Business Case"),
    subtitle(data.projectName),
    spacer(),

    // ── Executive Summary ──
    heading1("Executive Summary"),
    bodyText(data.executiveSummary),
    spacer(),

    // ── Problem Statement ──
    heading1("Problem Statement"),
    bodyText(data.problemStatement),
    spacer(),

    // ── Proposed Solution ──
    heading1("Proposed Solution"),
    bodyText(data.proposedSolution),
    spacer(),

    // ── Benefits ──
    heading1("Expected Benefits"),
    simpleTable(
      ["Benefit", "Type", "Estimated Value"],
      data.benefits.map((b) => [b.benefit, b.type, b.estimatedValue]),
      [45, 20, 35]
    ),
    spacer(),

    // ── Costs ──
    heading1("Estimated Costs"),
    simpleTable(
      ["Category", "Amount", "Notes"],
      data.costs.map((c) => [c.category, c.amount, c.notes]),
      [30, 25, 45]
    ),
    spacer(),

    // ── ROI ──
    heading1("Return on Investment"),
    labeledField("Projected ROI", data.roi),
    spacer(),

    // ── Risks ──
    heading1("Key Risks"),
    ...data.risks.map((r) => bulletItem(r)),
    spacer(),

    // ── Recommendation ──
    heading1("Recommendation"),
    bodyText(data.recommendation),

    divider(),
    bodyText("This document was generated by Brief-to-Project.", { italic: true }),
  ]);

  return Buffer.from(await Packer.toBuffer(doc));
}
