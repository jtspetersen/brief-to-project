/**
 * Project Schedule Document Generator
 *
 * Converts a schedule artifact (Stage 3) into a formatted Word document.
 */
import { Paragraph, Table } from "docx";
import {
  createDocument,
  Packer,
  title,
  subtitle,
  heading1,
  heading2,
  bodyText,
  labeledField,
  bulletItem,
  simpleTable,
  spacer,
  divider,
  s,
  a,
} from "./base-generator";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export async function generateSchedule(data: any): Promise<Buffer> {
  const content: (Paragraph | Table)[] = [
    title("Project Schedule"),
    subtitle(s(data.projectName)),
    spacer(),

    labeledField("Project Start", s(data.startDate)),
    labeledField("Project End", s(data.endDate)),
    spacer(),
  ];

  // Phase details
  for (const phase of a<any>(data.phases)) {
    content.push(heading1(s(phase?.name)));
    content.push(labeledField("Start", s(phase?.startDate)));
    content.push(labeledField("End", s(phase?.endDate)));

    if (a<any>(phase?.milestones).length > 0) {
      content.push(heading2("Milestones"));
      content.push(
        simpleTable(
          ["Milestone", "Target Date"],
          a<any>(phase?.milestones).map((m: any) => [s(m?.name), s(m?.date)]),
          [60, 40]
        )
      );
    }

    if (a<any>(phase?.dependencies).length > 0) {
      content.push(heading2("Dependencies"));
      for (const dep of a<any>(phase?.dependencies)) {
        content.push(bulletItem(s(dep)));
      }
    }

    if (a<any>(phase?.keyDeliverables).length > 0) {
      content.push(heading2("Key Deliverables"));
      for (const del of a<any>(phase?.keyDeliverables)) {
        content.push(bulletItem(s(del)));
      }
    }

    content.push(spacer());
  }

  // Critical Path
  if (a(data.criticalPath).length > 0) {
    content.push(heading1("Critical Path"));
    for (const item of a(data.criticalPath)) {
      content.push(bulletItem(s(item)));
    }
  }

  content.push(divider());
  content.push(bodyText("This document was generated by BriefKit.", { italic: true }));

  const doc = createDocument(content);
  return Buffer.from(await Packer.toBuffer(doc));
}
